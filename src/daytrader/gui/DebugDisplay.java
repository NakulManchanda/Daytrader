/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package daytrader.gui;

import com.ib.client.CommissionReport;
import com.ib.client.Contract;
import com.ib.client.ContractDetails;
import com.ib.client.EClientSocket;
import com.ib.client.EWrapper;
import com.ib.client.EWrapperMsgGenerator;
import com.ib.client.Execution;
import com.ib.client.Order;
import com.ib.client.OrderState;
import com.ib.client.UnderComp;
import daytrader.datamodel.AbstractGraphPoint;
import daytrader.datamodel.AtrClassEnum;
import daytrader.datamodel.BaseGraph;
import daytrader.datamodel.CallbackType;
import daytrader.datamodel.DTConstants;
import daytrader.datamodel.GraphLine;
import daytrader.datamodel.HistoricDataGraph;
import daytrader.datamodel.HistoricDataGraphPoint;
import daytrader.datamodel.MarketEnum;
import daytrader.datamodel.Putup;
import daytrader.datamodel.PutupTypeEnum;
import daytrader.datamodel.RealTimeRunManager;
import daytrader.datamodel.RealTimeRunRecord;
import daytrader.historicRequestSystem.HRSCallableWrapper;
import daytrader.historicRequestSystem.HistoricRequestProcessingSystem;
import daytrader.historicRequestSystem.TWSAccount;
import daytrader.interfaces.ICallback;
import daytrader.interfaces.IGraphLine;
import daytrader.utils.DTUtil;
import daytrader.utils.DataGraphLoader;
import daytradertasks.Load1DayBarsHighPoints;
import daytradertasks.LoadGivenDaysDataTask;
import daytradertasks.LoadHistoricDataPointBatchResult;
import daytradertasks.LoadHistoricDataPointBatchTaskDEPRICATED;
import daytradertasks.LoadToGivenTimeTask;
import daytradertasks.RequestMarketDataTask;
import java.awt.Color;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JOptionPane;
import rules.FinaliseProvYLines;
import rules.GeneratePotentialCELines;
import rules.TestRoundOneComplete;

/**
 *
 * @author Roy
 */
public class DebugDisplay extends javax.swing.JPanel implements EWrapper {

    private boolean connected = false;
    public boolean m_bIsFAAccount = false;
    private boolean m_disconnectInProgress = false;
    private EClientSocket m_client = new EClientSocket(this);
    private String m_FAAcctCodes;
    private int nextOrderId = -1;
    public static int conId = -1;
    private BaseGraph<AbstractGraphPoint> objHistoricData;

    public EClientSocket getM_client() {
        return m_client;
    }

    /**
     * Creates new form DebugDisplay
     */
    public DebugDisplay() {
        initComponents();
        initialise();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnConnect = new javax.swing.JButton();
        pnlHistoricData = new javax.swing.JPanel();
        jcalStartDay = new com.toedter.calendar.JCalendar();
        jcalStartDay.setLocale(Locale.US);
        jcalEndDay = new com.toedter.calendar.JCalendar();
        jcalEndDay.setLocale(Locale.US);
        lblStart = new javax.swing.JLabel();
        lblEnd = new javax.swing.JLabel();
        lblTicker = new javax.swing.JLabel();
        txtTicker = new javax.swing.JTextField();
        lblFileName = new javax.swing.JLabel();
        txtFileName = new javax.swing.JTextField();
        btnRetrieveData = new javax.swing.JButton();
        lblMarket = new javax.swing.JLabel();
        cbxMarket = new javax.swing.JComboBox();
        btnCSV = new javax.swing.JButton();
        btnLowestPoint = new javax.swing.JButton();
        btnLoadBAX = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        btnYLineTest = new javax.swing.JButton();
        btnLoadADay = new javax.swing.JButton();
        btnSwitch = new javax.swing.JButton();

        btnConnect.setBackground(new java.awt.Color(255, 102, 102));
        btnConnect.setText("Connect");
        btnConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnConnectActionPerformed(evt);
            }
        });

        pnlHistoricData.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));

        lblStart.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblStart.setText("Start of period");
        lblStart.setToolTipText("Select period start date");
        lblStart.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        lblEnd.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblEnd.setText("End of period");
        lblEnd.setToolTipText("Select period end date");
        lblEnd.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        lblTicker.setText("Ticker to retrieve data for: ");

        txtTicker.setText("HCN");
        txtTicker.setToolTipText("");

        lblFileName.setText("Save CSV to");

        txtFileName.setText("testData");
        txtFileName.setToolTipText("Enter file name");

        btnRetrieveData.setText("Retrieve Data");
        btnRetrieveData.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRetrieveDataActionPerformed(evt);
            }
        });

        lblMarket.setText("Select Market");

        btnCSV.setText("Write Data to CSV File");
        btnCSV.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCSVActionPerformed(evt);
            }
        });

        btnLowestPoint.setText("CE Lines Test");
        btnLowestPoint.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLowestPointActionPerformed(evt);
            }
        });

        btnLoadBAX.setText("Load BAX Test Data");
        btnLoadBAX.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLoadBAXActionPerformed(evt);
            }
        });

        jButton1.setText("Save All Graphs");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        btnYLineTest.setText("YLines Test");
        btnYLineTest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnYLineTestActionPerformed(evt);
            }
        });

        btnLoadADay.setText("Load Test");
        btnLoadADay.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLoadADayActionPerformed(evt);
            }
        });

        btnSwitch.setText("Switch Accounts");
        btnSwitch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSwitchActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlHistoricDataLayout = new javax.swing.GroupLayout(pnlHistoricData);
        pnlHistoricData.setLayout(pnlHistoricDataLayout);
        pnlHistoricDataLayout.setHorizontalGroup(
            pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                        .addComponent(lblTicker)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtTicker, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(lblMarket)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(cbxMarket, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                        .addComponent(lblFileName)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtFileName))
                    .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                        .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(lblStart, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jcalStartDay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                                .addGap(46, 46, 46)
                                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(btnLowestPoint, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnRetrieveData, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnYLineTest, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                        .addGap(18, 18, 18)
                        .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jcalEndDay, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(lblEnd, javax.swing.GroupLayout.PREFERRED_SIZE, 198, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(btnLoadADay, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnLoadBAX, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnCSV, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(39, 39, 39)
                                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jButton1)
                                    .addComponent(btnSwitch))))
                        .addGap(19, 19, 19)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        pnlHistoricDataLayout.setVerticalGroup(
            pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlHistoricDataLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblTicker)
                    .addComponent(txtTicker, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblMarket)
                    .addComponent(cbxMarket, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblFileName)
                    .addComponent(txtFileName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                        .addComponent(lblStart)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jcalStartDay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(pnlHistoricDataLayout.createSequentialGroup()
                        .addComponent(lblEnd)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jcalEndDay, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(btnCSV)
                        .addComponent(jButton1))
                    .addComponent(btnRetrieveData))
                .addGap(18, 18, 18)
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnLowestPoint)
                    .addComponent(btnLoadBAX)
                    .addComponent(btnSwitch))
                .addGap(18, 18, 18)
                .addGroup(pnlHistoricDataLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(btnYLineTest)
                    .addComponent(btnLoadADay))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        DefaultComboBoxModel newModel = new DefaultComboBoxModel(MarketEnum.values());
        cbxMarket.setModel(newModel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(btnConnect)
                .addGap(0, 0, Short.MAX_VALUE))
            .addComponent(pnlHistoricData, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(btnConnect)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pnlHistoricData, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 22, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void btnConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConnectActionPerformed
        // TODO add your handling code here:
        if (!connected) {
            onConnect();
        } else {
            onDisconnect();
        }
    }//GEN-LAST:event_btnConnectActionPerformed

    private void btnRetrieveDataActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRetrieveDataActionPerformed
        // TODO add your handling code here:
        //retrieveHistoricData();
        //retrieveHistoricData2();
        retrieveHistoricData3();
    }//GEN-LAST:event_btnRetrieveDataActionPerformed

    private void btnCSVActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCSVActionPerformed
        // TODO add your handling code here:
        writeCSVFile();
    }//GEN-LAST:event_btnCSVActionPerformed

    private void btnLowestPointActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLowestPointActionPerformed
        // TODO add your handling code here:
        doCELinesCalc();
    }//GEN-LAST:event_btnLowestPointActionPerformed

    private void btnLoadBAXActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadBAXActionPerformed
        // TODO add your handling code here:
        loadTestData();
    }//GEN-LAST:event_btnLoadBAXActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        saveAllGraphs();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void btnYLineTestActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnYLineTestActionPerformed
        // TODO add your handling code here:
        doYLines2();
    }//GEN-LAST:event_btnYLineTestActionPerformed

    private void btnLoadADayActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadADayActionPerformed
        // TODO add your handling code here:
        testLoadADay();
    }//GEN-LAST:event_btnLoadADayActionPerformed

    private void btnSwitchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSwitchActionPerformed
        // TODO add your handling code here:
        switchAcc();
    }//GEN-LAST:event_btnSwitchActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCSV;
    private javax.swing.JButton btnConnect;
    private javax.swing.JButton btnLoadADay;
    private javax.swing.JButton btnLoadBAX;
    private javax.swing.JButton btnLowestPoint;
    private javax.swing.JButton btnRetrieveData;
    private javax.swing.JButton btnSwitch;
    private javax.swing.JButton btnYLineTest;
    private javax.swing.JComboBox cbxMarket;
    private javax.swing.JButton jButton1;
    private com.toedter.calendar.JCalendar jcalEndDay;
    private com.toedter.calendar.JCalendar jcalStartDay;
    private javax.swing.JLabel lblEnd;
    private javax.swing.JLabel lblFileName;
    private javax.swing.JLabel lblMarket;
    private javax.swing.JLabel lblStart;
    private javax.swing.JLabel lblTicker;
    private javax.swing.JPanel pnlHistoricData;
    private javax.swing.JTextField txtFileName;
    private javax.swing.JTextField txtTicker;
    // End of variables declaration//GEN-END:variables

    private void onConnect() {
        m_bIsFAAccount = false;
        // get connection parameters
//        ConnectDlg dlg = new ConnectDlg( this);
//        dlg.setVisible(true);
//        if( !dlg.m_rc) {
//            return;
//        }
        ConnectDlg dlg = new ConnectDlg(null, true);
        dlg.setVisible(true);


        // connect to TWS
        m_disconnectInProgress = false;

//        m_client.eConnect( dlg.m_retIpAddress, dlg.m_retPort, dlg.m_retClientId);
        m_client.eConnect(dlg.getM_retIpAddress(), dlg.getM_retPort(), dlg.getM_retClientId());
        if (m_client.isConnected()) {
            connected = true;
            btnConnect.setBackground(Color.GREEN);
            btnConnect.setText("Disconnect");
            conId = dlg.getM_retClientId();
//            Removed button shows status
//            m_TWS.add("Connected to Tws server version " +
//                       m_client.serverVersion() + " at " +
//                       m_client.TwsConnectionTime());
            JOptionPane.showMessageDialog(null, "Connected to Server Version: "
                    + m_client.serverVersion() + " at " + m_client.TwsConnectionTime(), "Connection Successful", JOptionPane.INFORMATION_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(null, "Error connecting to API", "Connection Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    public void onDisconnect() {
        // disconnect from TWS
        m_disconnectInProgress = true;
        m_client.eDisconnect();
        connected = false;
        btnConnect.setBackground(new Color(255, 102, 102));
        btnConnect.setText("Connect");
        conId = -1;
        m_disconnectInProgress = false;
    }

    @Override
    public void tickPrice(int tickerId, int field, double price, int canAutoExecute) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void tickSize(int tickerId, int field, int size) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void tickOptionComputation(int tickerId, int field, double impliedVol, double delta, double optPrice, double pvDividend, double gamma, double vega, double theta, double undPrice) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void tickGeneric(int tickerId, int tickType, double value) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void tickString(int tickerId, int tickType, String value) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void tickEFP(int tickerId, int tickType, double basisPoints, String formattedBasisPoints, double impliedFuture, int holdDays, String futureExpiry, double dividendImpact, double dividendsToExpiry) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void orderStatus(int orderId, String status, int filled, int remaining, double avgFillPrice, int permId, int parentId, double lastFillPrice, int clientId, String whyHeld) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void openOrder(int orderId, Contract contract, Order order, OrderState orderState) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void openOrderEnd() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateAccountValue(String key, String value, String currency, String accountName) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updatePortfolio(Contract contract, int position, double marketPrice, double marketValue, double averageCost, double unrealizedPNL, double realizedPNL, String accountName) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateAccountTime(String timeStamp) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void accountDownloadEnd(String accountName) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void nextValidId(int orderId) {
        this.nextOrderId = orderId;
    }

    @Override
    public void contractDetails(int reqId, ContractDetails contractDetails) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void bondContractDetails(int reqId, ContractDetails contractDetails) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void contractDetailsEnd(int reqId) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void execDetails(int reqId, Contract contract, Execution execution) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void execDetailsEnd(int reqId) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateMktDepth(int tickerId, int position, int operation, int side, double price, int size) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateMktDepthL2(int tickerId, int position, String marketMaker, int operation, int side, double price, int size) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void updateNewsBulletin(int msgId, int msgType, String message, String origExchange) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void managedAccounts(String accountsList) {
        m_bIsFAAccount = true;
        m_FAAcctCodes = accountsList;
        String msg = EWrapperMsgGenerator.managedAccounts(accountsList);
        System.out.println(msg);
    }

    @Override
    public void receiveFA(int faDataType, String xml) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    /**
     * This is the callback that returns data from the server! Each input to
     * this callback function represents A piece of requested data from the
     * server.
     */
    @Override
    public void historicalData(int reqId, String date, double open, double high, double low, double close, int volume, int count, double WAP, boolean hasGaps) {
        //While I work on getting the whole day just spam the data to the console
        System.out.println("ID=" + reqId
                + ", " + date
                + ", open=" + open
                + ", high=" + high
                + ", low=" + low
                + ", close=" + close
                + ", volume=" + volume
                + ", count=" + count
                + ", WAP=" + WAP
                + ", hasGaps=" + hasGaps);
        if (null != this.objHistoricData) {
            if (!date.contains("finished")) {
                HistoricDataGraphPoint newItem = new HistoricDataGraphPoint(reqId, date, open, high, low, close, volume, count, WAP, hasGaps);
                this.objHistoricData.add(newItem);
            }
        }
    }

    @Override
    public void scannerParameters(String xml) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void scannerData(int reqId, int rank, ContractDetails contractDetails, String distance, String benchmark, String projection, String legsStr) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void scannerDataEnd(int reqId) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void realtimeBar(int reqId, long time, double open, double high, double low, double close, long volume, double wap, int count) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void currentTime(long time) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void fundamentalData(int reqId, String data) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void deltaNeutralValidation(int reqId, UnderComp underComp) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void tickSnapshotEnd(int reqId) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void marketDataType(int reqId, int marketDataType) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void commissionReport(CommissionReport commissionReport) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void error(Exception e) {
        System.err.println("Error invoked: " + e.getMessage());
    }

    @Override
    public void error(String str) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void error(int id, int errorCode, String errorMsg) {
        System.err.println("Error id: " + id + ", Error Code = " + errorCode + ", Message = " + errorMsg);
        if (errorCode == 162) {
            JOptionPane.showMessageDialog(null, "Pacing Violation, data lost, load data slower!!!", "Data Lost...", JOptionPane.ERROR_MESSAGE);
        }
    }

    @Override
    public void connectionClosed() {
        connected = false;
        btnConnect.setBackground(new Color(255, 102, 102));
        btnConnect.setText("Connect");
        conId = -1;
    }

    private void initialise() {
        //Initialisation code
        jcalStartDay.addPropertyChangeListener(new StartDateChange());
        jcalEndDay.addPropertyChangeListener(new EndDateChanged());
    }
    
    private RealTimeRunManager currManager;
    private GeneratePotentialCELines CELinesRule;

    private void retrieveHistoricData2() {
        Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);

        Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
        dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
        dateTime.set(Calendar.HOUR_OF_DAY, 14);
        dateTime.set(Calendar.MINUTE, 30);
        dateTime.set(Calendar.SECOND, 0);
        dateTime.set(Calendar.MILLISECOND, 0);

        //Must assign a manager to the putup
        RealTimeRunManager manager = new RealTimeRunManager(objABC, true);
        this.currManager = manager;
        this.CELinesRule = new GeneratePotentialCELines();
        this.CELinesRule.setRealTimeRunManager(manager);
        manager.preLoadData();

        //TEST ONLY
        HistoricRequestProcessingSystem HRSys = HistoricRequestProcessingSystem.getInstance();
        LoadToGivenTimeTask loadTask = new LoadToGivenTimeTask(objABC, dateTime, manager);
        HRSCallableWrapper wrapper = new HRSCallableWrapper(loadTask);
        HRSys.submitRequest(wrapper);

        do {
            System.out.println("Loading the day.....");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException ex) {
                Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            }
        } while (!loadTask.isLoadComplete());

        this.objHistoricData = manager.getGraphHistoricData();
        System.out.println("Day is loaded");
        //TEST ONLY
    }
    
    private void retrieveHistoricData3() {
        Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);

        Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
        dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
        dateTime.set(Calendar.HOUR_OF_DAY, 10);
        dateTime.set(Calendar.MINUTE, 30);
        dateTime.set(Calendar.SECOND, 0);
        dateTime.set(Calendar.MILLISECOND, 0);

        //Must assign a manager to the putup
        RealTimeRunManager manager = new RealTimeRunManager(objABC, true);
        HistoricRequestProcessingSystem HRSys = HistoricRequestProcessingSystem.getInstance();
        TestRoundOneComplete task = new TestRoundOneComplete(manager, manager, dateTime);
        try {
            task.call();
        } catch (Exception ex) {
            Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println("Done");
    }

    private void retrieveHistoricData() {
        DataGraphLoader myLoader = new DataGraphLoader(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()).toString(), jcalStartDay.getDate(), jcalEndDay.getDate());
        try {

            Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);

            Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
            dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
            dateTime.set(Calendar.HOUR_OF_DAY, 11);
            dateTime.set(Calendar.MINUTE, 0);
            dateTime.set(Calendar.SECOND, 0);
            dateTime.set(Calendar.MILLISECOND, 0);

            //TEST ONLY
            HistoricRequestProcessingSystem HRSys = HistoricRequestProcessingSystem.getInstance();
            LoadGivenDaysDataTask loadTask = new LoadGivenDaysDataTask(objABC, dateTime);
            HRSCallableWrapper wrapper = new HRSCallableWrapper(loadTask);
            HRSys.submitRequest(wrapper);
            //TEST ONLY

//            this.objHistoricData = new BaseGraph<AbstractGraphPoint>();
//            this.objHistoricData.setPutup(objABC);
            //BaseGraph<AbstractGraphPoint> loadData = myLoader.loadData();
//            BaseGraph<AbstractGraphPoint> loadData = myLoader.loadDataToTime(dateTime);
//            loadData.setPutup(objABC);
//            this.objHistoricData = loadData;
//            BaseGraph<AbstractGraphPoint> graphClosePrevDayData = this.objHistoricData.getGraphClosePrevDayData();

            System.out.println("PRAY HARD");

            throw new IOException("You went TOO far");
        } catch (IOException ex) {
            Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, "Failure to load data. Message = " + ex.getMessage(), "Failed...", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void writeCSVFile() {
        if (null != this.objHistoricData) {
            File filDest = new File(txtFileName.getText() + ".csv");
            if (filDest.exists()) {
                filDest.delete();
            }
            BufferedWriter out = null;
            boolean blnSaved = false;
            try {
                filDest.createNewFile();
                out = new BufferedWriter(new FileWriter(filDest));
                out.write(this.objHistoricData.toCSVString());
                blnSaved = true;
            } catch (IOException ex) {
                Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
                JOptionPane.showMessageDialog(null, "Error saving to " + filDest.getPath(), "Save Error.." + ex.getMessage(), JOptionPane.ERROR_MESSAGE);
            } finally {
                if (null != out) {
                    try {
                        out.close();
                    } catch (IOException ex) {
                        Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
            if (blnSaved) {
                JOptionPane.showMessageDialog(null, "Data Saved", "Save Complete...", JOptionPane.INFORMATION_MESSAGE);
            } else {
                JOptionPane.showMessageDialog(null, "Data NOT Saved", "Save ERROR...", JOptionPane.ERROR_MESSAGE);
            }
        } else {
            JOptionPane.showMessageDialog(null, "No data has been loaded", "Missing Data...", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void doCELinesCalc() {
        if(null != this.CELinesRule && null != this.currManager){
            boolean ceResult = this.CELinesRule.runRule();
            if(ceResult){
                System.out.println("A Winning C-E Line was found");
            } else {
                System.out.println("The C-E Line Test Failed");
            }
        }
//        if (null != this.objHistoricData && 0 < this.objHistoricData.size() && null != this.currManager) {
//            GeneratePotentialCELines ceGen = new GeneratePotentialCELines(this.objHistoricData);
//            ArrayList<GraphLine> generateLines;
//            boolean retry = false;
//            do {
//                try {
//                    generateLines = ceGen.generateLines();
//                    retry = false;
//                } catch (LoadingAdditionalDataException ex) {
//                    retry = true;
//                    try {
//                        Thread.sleep(2000);
//                    } catch (InterruptedException ex1) {
//                        Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex1);
//                    }
//                }
//            } while (retry);
//            System.out.println("THE CE LINE");
//        } else {
//            JOptionPane.showMessageDialog(null, "Please Load Data", "Load data first..", JOptionPane.ERROR_MESSAGE);
//        }
//        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void loadTestData() {
        File data = new File("BAX_20130524_Part.csv");
        if (data.exists()) {
            BufferedReader br = null;
            String sCurrentLine;
            try {
                br = new BufferedReader(new FileReader(data));
                this.objHistoricData = new HistoricDataGraph();
                while ((sCurrentLine = br.readLine()) != null) {
                    //System.out.println(sCurrentLine);
                    if (!sCurrentLine.contains("Timestamp")) {
                        /**
                         * String[] parts = sCurrentLine.split(","); long ts =
                         * Long.parseLong(parts[0]); ts +=
                         * -1*(TimeZone.getDefault().getRawOffset()); Date
                         * theDate = new Date(ts); Calendar theCal =
                         * Calendar.getInstance(); theCal.setTime(theDate);
                         * Integer intMonth = theDate.getMonth() + 1; String
                         * strMonth = ""; if( intMonth >= 10){ strMonth =
                         * intMonth.toString(); }else{ strMonth = "0" +
                         * intMonth.toString(); } Integer intDay =
                         * theCal.get(Calendar.DAY_OF_MONTH); String strDay =
                         * ""; if(intDay < 10){ strDay = "0" +
                         * intDay.toString(); }else{ strDay = intDay.toString();
                         * } Integer intHour = theDate.getHours(); String
                         * strHours = ""; if(intHour < 10){ strHours = "0" +
                         * intHour.toString(); }else{ strHours =
                         * intHour.toString(); } Integer intMin =
                         * theDate.getMinutes(); String strMin = ""; if(intMin <
                         * 10){ strMin = "0" + intMin.toString(); }else{ strMin
                         * = intMin.toString(); } Integer intSec =
                         * theDate.getSeconds(); String strSec = ""; if(intSec <
                         * 10){ strSec = "0" + intSec.toString(); }else{ strSec
                         * = intSec.toString(); } Integer intYear =
                         * theDate.getYear() + 1900; double dblLast =
                         * Double.parseDouble(parts[2]); String strDate = "" +
                         * intYear.toString() + strMonth + strDay + " " +
                         * strHours + ":" + strMin + ":" + strSec;
                         * HistoricDataGraphPoint item = new
                         * HistoricDataGraphPoint(0, strDate, dblLast, dblLast,
                         * dblLast, dblLast, 0, 0, 0, false);
                         * this.objHistoricData.add(item);
                         */
                        HistoricDataGraphPoint item = new HistoricDataGraphPoint();
                        item.fromCSVString(sCurrentLine);
                        this.objHistoricData.add(item);
                    }
                }
            } catch (FileNotFoundException ex) {
                Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            } finally {
                try {
                    if (br != null) {
                        br.close();
                    }
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        } else {
            JOptionPane.showMessageDialog(null, "Test Data Missing!!!", "Missing File...", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void saveAllGraphs() {
        ArrayList<RealTimeRunRecord> runningRecords = DTConstants.getRunningRecords();
        if (null != runningRecords && 0 < runningRecords.size()) {
            ArrayList<BaseGraph<AbstractGraphPoint>> graphList = new ArrayList<BaseGraph<AbstractGraphPoint>>();
            for (RealTimeRunRecord currRec : runningRecords) {
                BaseGraph<AbstractGraphPoint> graph = currRec.getLoader().getGraph();
                graphList.add(graph);
            }

            boolean blnError = false;
            for (BaseGraph<AbstractGraphPoint> currGraph : graphList) {
                if (null != currGraph) {
                    String tickerCode = currGraph.getPutup().getTickerCode();
                    String fName = "RTGraph_" + tickerCode + ".csv";
                    File myFile = new File(fName);
                    if (myFile.exists()) {
                        myFile.delete();
                    }
                    BufferedWriter writer = null;
                    try {
                        myFile.createNewFile();
                        FileWriter fos = new FileWriter(myFile);
                        writer = new BufferedWriter(fos);
                        writer.write(currGraph.toCSVString());
                    } catch (FileNotFoundException ex) {
                        Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
                        blnError = true;
                        JOptionPane.showMessageDialog(null, ex.getMessage() + ": " + tickerCode, "File not found...", JOptionPane.ERROR_MESSAGE);
                    } catch (IOException ex) {
                        Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
                        blnError = true;
                        JOptionPane.showMessageDialog(null, "Data Not Saved For: " + tickerCode, "Error...", JOptionPane.INFORMATION_MESSAGE);
                    } finally {
                        if (null != writer) {
                            try {
                                writer.close();
                            } catch (IOException ex) {
                                Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
                                blnError = true;
                            }
                        }
                    }
                } else {
                    blnError = true;
                    JOptionPane.showMessageDialog(null, "No Graph to save", "No Graph", JOptionPane.ERROR_MESSAGE);
                }
            }
            if (!blnError) {
                JOptionPane.showMessageDialog(null, "All data was saved", "Saved...", JOptionPane.INFORMATION_MESSAGE);
            } else {
                JOptionPane.showMessageDialog(null, "Error occured while saving real time data", "Error saving...", JOptionPane.ERROR_MESSAGE);
            }
        } else {
            if (null == runningRecords) {
                JOptionPane.showMessageDialog(null, "RunningRecords is NULL", "NULL", JOptionPane.ERROR_MESSAGE);
            } else if (0 < runningRecords.size()) {
                JOptionPane.showMessageDialog(null, "RunningRecords has 0 size", "ZERO", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void doYLines() {
        DataGraphLoader myLoader = new DataGraphLoader(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()).toString(), jcalStartDay.getDate(), jcalEndDay.getDate());
        try {
            Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);
            Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
            dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
            dateTime.set(Calendar.HOUR_OF_DAY, 9);
            dateTime.set(Calendar.MINUTE, 30);
            dateTime.set(Calendar.SECOND, 50);

            objABC.setTodaysDate(dateTime);

            BaseGraph<AbstractGraphPoint> loadData = myLoader.loadDataToTime(dateTime);
            loadData.setPutup(objABC);
            this.objHistoricData = loadData;

//            this.objHistoricData = new BaseGraph<AbstractGraphPoint>();
//            this.objHistoricData.setPutup(objABC);

            System.out.println("PRAY HARD");

            //Y Line Testing Code - START
            File fM3D1HighPoints = new File("M3D1HighPoints.xml");
            File fHR1HighPoints = new File("HR1HighPoints.xml");
            File fMin15BarsHighPoints = new File("Min15BarsHighPoints.xml");
            File fSec1BarsHighPoints = new File("Sec1BarsHighPoints.xml");
            //
            //            //Initial File Creation Code - START
            //
            //MUST go back one day or its not Y lines
            Calendar cal = DTUtil.dateToCalendar(jcalEndDay.getCalendar().getTime());
            cal.add(Calendar.DAY_OF_MONTH, -1);
            cal = DTUtil.getExchClosingCalendar(cal);

            Calendar backTo = Calendar.getInstance(cal.getTimeZone());
            backTo.setTimeInMillis(cal.getTimeInMillis());
            backTo.add(Calendar.DAY_OF_MONTH, -0);
            backTo = DTUtil.getExchOpeningCalendar(backTo);
            //            Calendar cal = objHistoricData.getPutup().getMaxYLineDate();
            //LOAD Y LINE TEST USING FILES - START
//                        BaseGraph<AbstractGraphPoint> M3D1HighPoints = new BaseGraph<AbstractGraphPoint>();
//                        M3D1HighPoints.loadGraphFromFile(fM3D1HighPoints.getPath());
//                        myLoader.manuallySetMonthCache(M3D1HighPoints);
//                        BaseGraph<AbstractGraphPoint> HR1HighPoints = new BaseGraph<AbstractGraphPoint>();
//                        HR1HighPoints.loadGraphFromFile(fHR1HighPoints.getPath());
//                        BaseGraph<AbstractGraphPoint> Min15BarsHighPoints = new BaseGraph<AbstractGraphPoint>();
//                        Min15BarsHighPoints.loadGraphFromFile(fMin15BarsHighPoints.getPath());
//                        BaseGraph<AbstractGraphPoint> result = new BaseGraph<AbstractGraphPoint>();
//                        result.loadGraphFromFile(fSec1BarsHighPoints.getPath());
            //LOAD Y LINE TEST USING FILES - END
            BaseGraph<AbstractGraphPoint> M3D1HighPoints = myLoader.get3Month1DBarsHighPoints(objHistoricData, cal, backTo);
            M3D1HighPoints.setPutup(objABC);
            M3D1HighPoints.saveToXMLFile(fM3D1HighPoints);
            BaseGraph<AbstractGraphPoint> HR1HighPoints = myLoader.get1HrBarsHighPoints(M3D1HighPoints, cal);
            HR1HighPoints.setPutup(objABC);
            HR1HighPoints.saveToXMLFile(fHR1HighPoints);
            BaseGraph<AbstractGraphPoint> Min15BarsHighPoints = myLoader.get15MinBarsHighPoints(HR1HighPoints, cal);
            Min15BarsHighPoints.setPutup(objABC);
            Min15BarsHighPoints.saveToXMLFile(fMin15BarsHighPoints);
            BaseGraph<AbstractGraphPoint> result = myLoader.get1SecBarsLastPoints(Min15BarsHighPoints, cal);
            result.setPutup(objABC);
            result.saveToXMLFile(fSec1BarsHighPoints);
            //Initial File Creation Code - END
            //Now I have data look for the Y Lines + stand ins

            //First step generate a combined graph that includes today and previous day data. The above loads previous
            //day data so store this into the previous day and the temp graph
            this.objHistoricData.addPreviousGraph(result.last().getDateAsNumber(), result);
            this.objHistoricData.createTempGraph(result);
            this.objHistoricData.mergeCurrAndTempGraph();
            this.objHistoricData.getTempGraph().setTradingDaysFromGraph();

            //ArrayList<GraphLine> lstYLines = myLoader.generateProvisionalYLines(result);
            ArrayList<GraphLine> lstYLines = myLoader.generateProvisionalYLines(this.objHistoricData.getTempGraph());
            ArrayList<GraphLine> checkYLineStandIns2 = myLoader.checkYLineStandIns2(lstYLines, this.objHistoricData.getTempGraph(), false);
            //ArrayList<GraphLine> checkYLineStandIns = myLoader.checkYLineStandIns(lstYLines, this.objHistoricData.getTempGraph());
            this.objHistoricData.setYlines(checkYLineStandIns2);
            //this.objHistoricData.setTradingDays(result);
            System.out.println("Found a total of " + this.objHistoricData.getCurrentYLines().size() + " Y Lines");
            //objHistoricData contains today, yLines and trading day details test 'CURRENT Y LINES'
            ArrayList<IGraphLine> currentYLines = this.objHistoricData.getCurrentYLines();
            throw new IOException("Ignore this");
            //Y Line Testing Code - END
        } catch (IOException ex) {
            Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, "Failure to load data. Message = " + ex.getMessage(), "Failed...", JOptionPane.ERROR_MESSAGE);
        }
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void testLoadADay() {
        HistoricRequestProcessingSystem HRSys = HistoricRequestProcessingSystem.getInstance();
        Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);
        //Test of the historic data loading system
        Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
        dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
        dateTime.set(Calendar.HOUR_OF_DAY, 9);
        dateTime.set(Calendar.MINUTE, 30);
        dateTime.set(Calendar.SECOND, 50);
        this.objHistoricData = new BaseGraph<AbstractGraphPoint>();
        this.objHistoricData.setPutup(objABC);
//        UpdateToHistoricDataCallback cb = new UpdateToHistoricDataCallback(this.objHistoricData);
//        LoadHistoricDataBatchTask task = new LoadHistoricDataBatchTask(objABC, dateTime, cb);
//        HRSCallableWrapper wrapper = new HRSCallableWrapper(task, PriorityEnum.IMMEDIATE);
//        HRSys.submitRequest(wrapper);
        //        while(0 == this.objHistoricData.size()){
        //            System.out.println("Still ZERO");
        //        }
        //
        //        System.out.println("Exited with a size of: " + this.objHistoricData.size());
        TWSAccount generalAcc = HRSys.getAccounts().getGeneralAcc();
        ExecutorService executor = Executors.newFixedThreadPool(1);;
        ExecutorCompletionService executionService = new ExecutorCompletionService(executor);
        RequestMarketDataTask task = new RequestMarketDataTask(objHistoricData, generalAcc);
        executionService.submit(task);

    }

    private void switchAcc() {
        Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);
        Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
        dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
        dateTime.set(Calendar.HOUR_OF_DAY, 10);
        dateTime.set(Calendar.MINUTE, 0);
        dateTime.set(Calendar.SECOND, 0);

        int counter = 0;

        ExecutorService pool = Executors.newFixedThreadPool(1);
        CompletionService<LoadHistoricDataPointBatchResult> service = new ExecutorCompletionService(pool);
        for (int i = 0; i < 5; i++) {
            Calendar currDay = DTUtil.getExchClosingCalendar(dateTime);
            boolean blnEven = false;
            if (0 == i % 2) {
                blnEven = true;
            }
            int account = 0;
            if (blnEven) {
                account = DTConstants.CONNECTION_PORT;
            } else {
                account = DTConstants.CONNECTION_PORT_ACC_2;
            }

            //Make 13 request for a day
            for (int j = 0; j < 13; j++) {
                LoadHistoricDataPointBatchTaskDEPRICATED loadTask = new LoadHistoricDataPointBatchTaskDEPRICATED(objABC, currDay, account);
                service.submit(loadTask);
                System.out.println("Sent request to port: " + account + " for time " + currDay.getTime().toString());
                counter++;
                currDay.add(Calendar.MINUTE, -30);
            }
            dateTime.add(Calendar.DAY_OF_MONTH, -1);
        }
        try {
            for (int i = 0; i < counter; i++) {
                try {
                    Future<LoadHistoricDataPointBatchResult> f = service.take();
                    LoadHistoricDataPointBatchResult result = f.get();
                    System.out.println("Result holds " + result.loadedPoints.size() + " points. This was result number: " + i);
                } catch (Throwable ex) {
                    System.err.println("Task No: " + i + " threw an exception: " + ex.getMessage());
                    if (ex instanceof InterruptedException) {
                        throw (InterruptedException) ex;
                    }
                }
            }
            System.out.println("ALL DONE");
        } catch (InterruptedException ex) {
            Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, "Interrupted loading data", "Error...", JOptionPane.ERROR_MESSAGE);
        }
//        } catch (ExecutionException ex) {
//            Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
//            JOptionPane.showMessageDialog(null, "Exception loading data: " + ex.getMessage(), "Error...", JOptionPane.ERROR_MESSAGE);
//        }
    }

    private void doYLines2() {
        try {
            Putup objABC = new Putup(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()), PutupTypeEnum.LONGS, 82100, AtrClassEnum.MH);
            
            //Setup a dummy runtime manager (do not make initial request)
            RealTimeRunManager manager = new RealTimeRunManager(objABC, false);
            
            Calendar dateTime = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
            dateTime.setTimeInMillis(jcalStartDay.getDate().getTime());
            dateTime.set(Calendar.HOUR_OF_DAY, 9);
            dateTime.set(Calendar.MINUTE, 30);
            dateTime.set(Calendar.SECOND, 50);
            dateTime.set(Calendar.MILLISECOND, 0);
            objABC.setTodaysDate(dateTime);

            DataGraphLoader myLoader = new DataGraphLoader(txtTicker.getText(), ((MarketEnum) cbxMarket.getSelectedItem()).toString(), jcalStartDay.getDate(), jcalEndDay.getDate());
            BaseGraph<AbstractGraphPoint> loadData = myLoader.loadDataToTime(dateTime);
            loadData.setPutup(objABC);
            this.objHistoricData = loadData;

            //Setup Max Y Line date
            Calendar maxYDate = Calendar.getInstance(DTConstants.EXCH_TIME_ZONE);
            maxYDate.set(Calendar.YEAR, 2013);
            maxYDate.set(Calendar.MONTH, Calendar.MARCH);
            maxYDate.set(Calendar.DAY_OF_MONTH, 8);
            maxYDate.set(Calendar.HOUR_OF_DAY, 9);
            maxYDate.set(Calendar.MINUTE, 30);
            maxYDate.set(Calendar.SECOND, 0);
            maxYDate.set(Calendar.MILLISECOND, 0);

            objABC.setMaxYLineDate(maxYDate);
            
            

            //Start PRE-Load Code
            //objABC.preLoadYLines();
            //END PRE-Load Code

            //OR LOAD FROM FILE
            //START Load from File
            String fileName = objABC.getTickerCode() + "_PRELOAD.xml";
            BaseGraph<AbstractGraphPoint> yLineData = new BaseGraph<AbstractGraphPoint>();
            yLineData.setPutup(objABC);
            yLineData.loadGraphFromFile(fileName);
            objABC.setPreLoadedYLineGraph(yLineData);
            //LOAD THE DAMN 1 DAY BARS CACHE START
            DeliverMonthCache cb = new DeliverMonthCache(objABC);
            Load1DayBarsHighPoints loadTask = new Load1DayBarsHighPoints(objABC, objABC.getTodaysDate(), objABC.getMaxYLineDate(), cb);
            HRSCallableWrapper wrapper = new HRSCallableWrapper(loadTask);
            HistoricRequestProcessingSystem HRSys = HistoricRequestProcessingSystem.getInstance();
            HRSys.submitRequest(wrapper);
            //BLOCK UNTIL LOADED
            while (null == objABC.getMonthCache()) {
                System.out.println("NO CACHE");
            }
            System.out.println("GOT CACHE");
            //LOAD THE DAMN 1 DAY BARS CACHE END
            //END LOAD FROM FILE

            //Store historic data into putups graph
            manager.getGraphHistoricData().addAll(this.objHistoricData);
            
            this.objHistoricData.addPreviousGraph(yLineData.last().getDateAsNumber(), yLineData);
            this.objHistoricData.createTempGraph(yLineData);
            this.objHistoricData.mergeCurrAndTempGraph();
            this.objHistoricData.getTempGraph().setTradingDaysFromGraph();
            
            ArrayList<IGraphLine> provisionalYLines = objABC.generateProvisionalYLines(objABC.getPreLoadedYLineGraph());
            objABC.setInitialYLines(provisionalYLines);
            ArrayList<IGraphLine> checkYLinesForStandIns = objABC.checkYLinesForStandIns(provisionalYLines, objABC.getPreLoadedYLineGraph());
            objABC.setInitialYLines(checkYLinesForStandIns);
            //Now test to see if the provisional Y Lines can be changed into the 'final' Y-Lines
            FinaliseProvYLines finaliser = new FinaliseProvYLines();
            finaliser.finaliseYLinesForPutup(objABC);
            ArrayList<IGraphLine> finalYLines = finaliser.getFinalYLines();
            System.out.println("FINAL Y-LINE's");
            if(0 == finalYLines.size()){
                System.out.println("No Y-Lines where found.");
            }else{
                int intYLineNo = -1;
                for(IGraphLine currLine : finalYLines){
                    intYLineNo++;
                    String msg = "Y-Line No: " + intYLineNo + ", Start Point = " + currLine.getCurrentC().toString() + ", End Point = " + currLine.getCurrentE().toString();
                    System.out.println(msg);
                }
            }
            System.out.println("Y-Lines Completed.");

        } catch (Exception ex) {
            Logger.getLogger(DebugDisplay.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, "Failure to load data. Message = " + ex.getMessage(), "Failed...", JOptionPane.ERROR_MESSAGE);
        }
    }

    @Override
    public void position(String account, Contract contract, int pos, double avgCost) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void positionEnd() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void accountSummary(int reqId, String account, String tag, String value, String currency) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void accountSummaryEnd(int reqId) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private class StartDateChange implements PropertyChangeListener {

        @Override
        public void propertyChange(PropertyChangeEvent evt) {
            if (evt.getPropertyName().equalsIgnoreCase("calendar")) {
                Date date = jcalStartDay.getDate();
                jcalEndDay.setDate(date);
                //jcalEndDay.repaint();
            }
        }
    }

    private class EndDateChanged implements PropertyChangeListener {

        @Override
        public void propertyChange(PropertyChangeEvent evt) {
            if (evt.getPropertyName().equalsIgnoreCase("calendar")) {
                Date date = jcalEndDay.getDate();
                if (date.before(jcalStartDay.getDate())) {
                    JOptionPane.showMessageDialog(null, "End date must be AFTER start date", "Invalid Date range", JOptionPane.ERROR_MESSAGE);
                    jcalEndDay.setDate(jcalStartDay.getDate());
                    //jcalEndDay.repaint();
                }
            }
        }
    }

    //This class is used for YLine testing only
    private class DeliverMonthCache implements ICallback {

        private Putup target;

        public DeliverMonthCache(Putup target) {
            this.target = target;
        }

        @Override
        public void callback(CallbackType type, Object data) {
            switch (type) {
                case YLINES1DAYBARS:
                    if (data instanceof LoadHistoricDataPointBatchResult) {
                        LoadHistoricDataPointBatchResult result = (LoadHistoricDataPointBatchResult) data;
                        //Now send the 1 Day Bars to the Putup to store as its month cache (needed for gradient calculations across days)
                        this.target.callback(CallbackType.YLINEMONTHCACHE, result.loadedPoints);
                    }
                    break;
            }
        }
    }
}
