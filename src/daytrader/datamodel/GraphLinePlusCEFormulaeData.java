/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package daytrader.datamodel;

import daytrader.interfaces.IGraphLine;
import java.util.TreeSet;

/**
 * In determining CE Line(s) that need to be used to decide if a stock should be
 * purchased each start / end point of the involved Graph Line requires certain 
 * values to be calculated and stored. These values are encapsulated in the 
 * PointsCEFormulaData class along with the price / time point to which they relate.
 * 
 * However in discussing the implementation of the CE Lines he seems incapable of
 * maintaining the distinction between a point + the associated calculated values 
 * and the Graph Line that contains a start and end point each of which has its 
 * own values. His descriptions freely move from discussing a point and its data
 * to discussing a line and its X / Y values (even though the line has at least 
 * two points each with their own X / Y values). Eventually a decided that the only
 * way to manage these concepts sensibly was to have a class that encapsulated a
 * GraphLine AND the CEFormulaData for its 'C' and 'E' points. This class is the 
 * result, it implements the IGraphLine interface so that it 'is a' GraphLine 
 * while at the same time providing access to the CEFormulaData for the lines 
 * start and end points.
 * 
 * This class encapsulates a Graph Line and the Y and X values for both the 'C'
 * and 'E' points of the line
 *
 * @author Roy
 */
public class GraphLinePlusCEFormulaeData implements IGraphLine {

    private IGraphLine sourceLine;
    private TreeSet<PointsCEFormulaData> finalPointList;
    private PointsCEFormulaData cPointData;
    private PointsCEFormulaData ePointData;

    /**
     * Constructor that accepts an IGraphLine interface and a TreeSet containing a list
     * of all the points for which the CEFormulaData has been computed. This list is searched
     * and the data relating to the IGraphLines 'C' and 'E' points is extracted 
     * from the TreeSet and stored into this object.
     * @param newSourceLine - The IGraphLine to be encapsulated with its 'C' and 'E' point formula data
     * @param newFinalPointList - A TreeSet of PointsCEFormulaData that encapsulates 
     * the data generated by the CE Lines calculation.
     */
    public GraphLinePlusCEFormulaeData(IGraphLine newSourceLine, TreeSet<PointsCEFormulaData> newFinalPointList) {
        this.sourceLine = newSourceLine;
        this.finalPointList = newFinalPointList;
        AbstractGraphPoint startPoint = this.sourceLine.getStartPoint();
        AbstractGraphPoint endPoint = this.sourceLine.getEndPoint();
        for (PointsCEFormulaData currData : this.finalPointList) {
            AbstractGraphPoint aPoint = currData.getPoint();
            //Check if this is the 'C' points data, if so store it 
            if (aPoint.equals(startPoint)) {
                //Store this data for the 'C' point of this line
                this.cPointData = currData;
            }
            //Check if this is the 'E' points data, if so store it 
            if (aPoint.equals(endPoint)) {
                //Store this data for the 'E' point of this line
                this.ePointData = currData;
            }
            //IF data has been found for both C and E points we can break out of the loop
            if (null != this.cPointData && null != this.ePointData) {
                break;
            }
        }
    }

    //INTERFACE IGraphLine - START
    @Override
    public AbstractGraphPoint getCurrentC() {
        return this.sourceLine.getCurrentC();
    }

    @Override
    public AbstractGraphPoint getCurrentE() {
        return this.sourceLine.getCurrentE();
    }

    @Override
    public AbstractGraphPoint getEndPoint() {
        return this.sourceLine.getEndPoint();
    }

    @Override
    public double getGradient() {
        return this.sourceLine.getGradient();
    }

    @Override
    public BaseGraph<AbstractGraphPoint> getGraph() {
        return this.sourceLine.getGraph();
    }

    @Override
    public LineDirectionEnum getLinedirection() {
        return this.sourceLine.getLinedirection();
    }

    @Override
    public AbstractGraphPoint getPointAtTime(long timestamp) {
        return this.sourceLine.getPointAtTime(timestamp);
    }

    @Override
    public double getPriceAtTime(long timestamp) {
        return this.sourceLine.getPriceAtTime(timestamp);
    }

    @Override
    public AbstractGraphPoint getStandInC() {
        return this.sourceLine.getStandInC();
    }

    @Override
    public AbstractGraphPoint getStandInE() {
        return this.sourceLine.getStandInE();
    }

    @Override
    public AbstractGraphPoint getStartPoint() {
        return this.sourceLine.getStartPoint();
    }

    @Override
    public TreeSet<Integer> getTradingDays() {
        return this.sourceLine.getTradingDays();
    }

    @Override
    public boolean isValid() {
        return this.sourceLine.isValid();
    }

    @Override
    public void setEndPoint(AbstractGraphPoint endPoint) {
        this.sourceLine.setEndPoint(endPoint);
    }

    @Override
    public void setGraph(BaseGraph<AbstractGraphPoint> graph) {
        this.sourceLine.setGraph(graph);
    }

    @Override
    public void setStandInC(AbstractGraphPoint standInC) {
        this.sourceLine.setStandInC(standInC);
    }

    @Override
    public void setStandInE(AbstractGraphPoint standInE) {
        this.sourceLine.setStandInE(standInE);
    }

    @Override
    public void setStartPoint(AbstractGraphPoint startPoint) {
        this.sourceLine.setStartPoint(startPoint);
    }

    @Override
    public void setTradingDays(TreeSet<Integer> tradingDays) {
        this.sourceLine.setTradingDays(tradingDays);
    }

    @Override
    public double xInterceptTime() {
        return this.sourceLine.xInterceptTime();
    }

    @Override
    public double yInterceptPrice() {
        return this.sourceLine.yInterceptPrice();
    }

    @Override
    public IGraphLine deepCopyLine() {
        return this.sourceLine.deepCopyLine();
    }

    @Override
    public boolean isACPoint(AbstractGraphPoint potentialCPoint) {
        return this.sourceLine.isACPoint(potentialCPoint);
    }
    
    @Override
    public AbstractGraphPoint getIntersect(IGraphLine targetLine){
        return this.sourceLine.getIntersect(targetLine);
    }
    
    @Override
    public int compareTo(IGraphLine o) {
        return this.sourceLine.compareTo(o);
    }

    //INTERFACE IGraphLine - END
    //Methods to access C-E Formulae data - START
    /**
     * Retrieves the C-E Formulae Data for the 'C' point of this line
     * @return A PointsCEFormulaData object that encapsulates the 'C' point for this
     * GraphLine and its associated CEFormulaData
     */
    public PointsCEFormulaData getCPointData() {
        return this.cPointData;
    }

    /**
     * Retrieves the C-E Formulae Data for the 'E' point of this line
     * @return A PointsCEFormulaData object that encapsulates the 'E' point for this
     * GraphLine and its associated CEFormulaData
     */
    public PointsCEFormulaData getEPointData() {
        return this.ePointData;
    }

    /**
     * Retrieves the 'Aggregate Y Score' for this GraphLine. This is defined as the 
     * sum of the Y Score for the 'C' point of the line and the Y score for the
     * 'E' point of the line
     * @return double being the sum of the C and E points Y Scores
     */
    public double getAggregateY() {
        return this.cPointData.getYScore() + this.ePointData.getYScore();
    }

    /**
     * Retrieves the 'Aggregate X Score' for this GraphLine. This is defined as the 
     * sum of the X Score for the 'C' point of the line and the X score for the
     * 'E' point of the line
     * @return double being the sum of the C and E points X Scores
     */
    public double getAggregateX() {
        return this.cPointData.getXScore() + this.ePointData.getXScore();
    }

    /**
     * This method tests if the current GraphLine 'survives' when played off
     * against another line. To survive the aggregate Y OR aggregate X score
     * must be equal to or greater than the target GraphLine to which it is compared
     * @param target - A GraphLinePlusCEFormulaeData that this object should be tested against
     * @return boolean True if either the aggregate Y or aggregate X scores of this 
     * GraphLinePlusCEFormulaeData are greater than or equal to the targets, False
     * otherwise.
     */
    public boolean survivesAgainst(GraphLinePlusCEFormulaeData target) {
        boolean result = true;
        if (null != target) {
            //Test if we survive on aggregate Y
            if (this.getAggregateY() < target.getAggregateY()) {
                //We have NOT survived on 'Y' try to survive on aggregate 'X'
                if (this.getAggregateX() < target.getAggregateX()) {
                    //We do NOT survive
                    result = false;
                }
            }
        }
        return result;
    }
    //Methods to access C-E Formulae data - END
}
